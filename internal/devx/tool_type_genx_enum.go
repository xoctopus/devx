// Code generated by genx:enum DO NOT EDIT.
package devx

import (
	"bytes"
	"database/sql/driver"
	"fmt"

	"github.com/xoctopus/x/enumx"
)

var _ enumx.Enum[ToolType] = (*ToolType)(nil)

// ParseToolType parse ToolType from key
func ParseToolType(key string) (ToolType, error) {
	switch key {
	case "LINTER":
		return TOOL_TYPE__LINTER, nil
	case "DOC":
		return TOOL_TYPE__DOC, nil
	case "FORMATER":
		return TOOL_TYPE__FORMATER, nil
	case "DEVGEN":
		return TOOL_TYPE__DEVGEN, nil
	default:
		var v ToolType
		if _, err := fmt.Sscanf(key, "UNKNOWN_%d", &v); err != nil {
			return v, nil
		}
		return TOOL_TYPE_UNKNOWN, enumx.ParseErrorFor[ToolType](key)
	}
}

// Values returns enum value list of ToolType
func (ToolType) Values() []ToolType {
	return []ToolType{
		TOOL_TYPE__LINTER,
		TOOL_TYPE__DOC,
		TOOL_TYPE__FORMATER,
		TOOL_TYPE__DEVGEN,
	}
}

// String returns v's string as key
func (v ToolType) String() string {
	switch v {
	case TOOL_TYPE__LINTER:
		return "LINTER"
	case TOOL_TYPE__DOC:
		return "DOC"
	case TOOL_TYPE__FORMATER:
		return "FORMATER"
	case TOOL_TYPE__DEVGEN:
		return "DEVGEN"
	default:
		return fmt.Sprintf("UNKNOWN_%d", v)
	}
}

// Text returns the description as for human reading
func (v ToolType) Text() string {
	switch v {
	case TOOL_TYPE__LINTER:
		return "code linting"
	case TOOL_TYPE__DOC:
		return "doc generating"
	case TOOL_TYPE__FORMATER:
		return "code formating"
	case TOOL_TYPE__DEVGEN:
		return "devgen"
	default:
		return v.String()
	}
}

// IsZero checks if v is zero
func (v ToolType) IsZero() bool {
	return v == TOOL_TYPE_UNKNOWN
}

// MarshalText implements encoding.TextMarshaler
func (v ToolType) MarshalText() ([]byte, error) {
	return []byte(v.String()), nil
}

// UnmarshalText implements encoding.TextUnmarshaler
func (v *ToolType) UnmarshalText(data []byte) error {
	vv, err := ParseToolType(string(bytes.ToUpper(data)))
	if err != nil {
		return err
	}
	*v = vv
	return nil
}

// Value implements driver.Valuer
func (v ToolType) Value() (driver.Value, error) {
	offset := 0
	if drv, ok := any(v).(enumx.DriverValueOffset); ok {
		offset = drv.Offset()
	}
	return int64(v) + int64(offset), nil
}

// Scan implements sql.Scanner
func (v *ToolType) Scan(src any) error {
	offset := 0
	if offsetter, ok := any(v).(enumx.DriverValueOffset); ok {
		offset = offsetter.Offset()
	}
	i, err := enumx.Scan(src, offset)
	if err != nil {
		return err
	}
	*v = ToolType(i)
	return nil
}
